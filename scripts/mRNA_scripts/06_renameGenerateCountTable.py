#!/usr/bin/env python
# -*- coding: utf-8 -*-

"""
DESCRIPTION:
------------
This script processes count data files from featureCounts and generates a combined count table and annotation file.
It reads multiple `.counts` files from a specified directory and merges the gene counts into a single table.
The script also generates a sample annotation file that includes sample, patient, condition, and type information.

OUTPUT:
-------
1. countTable.txt: A table with Ensembl gene IDs, sample IDs, and their corresponding counts.
2. colData.txt: An annotation file describing sample metadata (patient ID, condition, etc.).

USAGE:
------
python 10_renameGenerateCountTable.py /path/to/featureCounts_directory

ARGUMENTS:
----------
/path/to/featureCounts_directory: Directory containing `.counts` files generated by featureCounts.
"""

import os
import sys
import glob
from optparse import OptionParser

# Usage string for incorrect argument usage
usage_string = "USAGE: %s <featureCounts_directory>" % (sys.argv[0])

def main():
    # Parse command line options and arguments
    opt, arg = parseOpts()
    
    try:
        # Directory with featureCounts output files
        fCountsDirName = sys.argv[1]
    except IndexError:
        print(usage_string)
        sys.exit(1)

    # Output files for count table and annotation data
    outputFileName1 = os.path.join(fCountsDirName, "countTable.txt")
    outputFileName2 = os.path.join(fCountsDirName, "colData.txt")
    
    # Open the output files
    outputFile1 = open(outputFileName1, "w")
    outputFile2 = open(outputFileName2, "w")
    
    # Write headers to the count table
    print("\t".join(["Ensembl_Id", "Sample_Id", "Count"]), file=outputFile1)
    
    # Dictionary to store counts per gene and sample
    countsMap = {}
    
    # Get all `.counts` files in the directory
    allFiles = glob.glob(os.path.join(fCountsDirName, '*.counts'))
    counter = set()

    # Process each `.counts` file
    for i, aFile in enumerate(allFiles):
        sampleName = os.path.basename(aFile).split(".")[0]
        sampleLst = sampleName.split("-")
        sampleName = convertListToString(sampleLst, "-")
        
        # Merge counts from the current file into the countsMap
        mergeCounts(aFile, countsMap, sampleName)
        
        # Collect sample IDs from the counts map
        sampleIds = getSampleIds(countsMap)

        # Create annotation file for samples
        createAnnoFile(outputFile2, sorted(sampleIds))

        # Write counts to the count table
        for geneId in sorted(countsMap):
            for (sample, count) in countsMap[geneId]:
                print("\t".join([geneId, sample, count]), file=outputFile1)
                counter.add(sample)
    
    print(counter)
    
    # Close the output files
    outputFile1.close()
    outputFile2.close()

# Function to create the annotation file
def createAnnoFile(output, samples):
    print("\t".join(["sample", "patient", "condition", "type"]), file=output)
    
    exptype = "paired-read"
    condition = "case"
    counter = 0
    
    for sample in samples:
        counter += 1
        patient = str(counter)
        
        if sample.startswith("C"):
            condition = "control"
        elif sample.endswith("_V"):
            condition = "case-viral"
        else:
            condition = "case-bacterial"
        
        # Write the sample annotation details
        print("\t".join([sample, patient, condition, exptype]), file=output)

# Function to get all sample IDs from the counts map
def getSampleIds(counts):
    ids = set()
    for gene in counts:
        for (sample, _) in sorted(counts[gene]):
            ids.add(sample)
    return sorted(list(ids))

# Function to merge counts from a file into the counts map
def mergeCounts(inFile, cMap, sName):
    with open(inFile) as handle:
        handle.readline()  # Skip header
        for line in handle:
            fields = line.rstrip("\n").split("\t")
            geneId, fCounts = fields
            fillMap(cMap, geneId, (sName, fCounts))

# Helper function to convert a list to a string with a separator
def convertListToString(lst, sep):
    return sep.join(lst)

# Helper function to fill the counts map
def fillMap(aMap, key, val):
    if key not in aMap:
        aMap[key] = [val]
    else:
        aMap[key].append(val)

# Function to parse command line options and arguments
def parseOpts():
    usage = "Usage: %prog [options]"
    parser = OptionParser(usage)
    
    parser.add_option(
        "-n", "--networkmode",
        dest="networkmode",
        type="string",
        help="Network mode [within, between]"
    )

    opt, arg = parser.parse_args()
    return opt, arg

# Run the script
if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        pass